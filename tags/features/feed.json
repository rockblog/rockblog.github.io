{
    "version": "https://jsonfeed.org/version/1.1",
    "title": "Features on Rockblog",
    "description": "Thought and work on the redrock postgres database",
    "home_page_url" : "https://blog.rockdata.net/",
    "feed_url" : "https://blog.rockdata.net/tags/features/feed.json",
    "authors" : [
        {
            "name" : "John Doe"
        }
    ],
    "items" : [
        {
            "title" : "Undo",
            "date_published" : "2020-06-13T00:06:00+02:00",
            "date_modified" : "2022-05-23T20:13:05+08:00",
            "id" : "https://blog.rockdata.net/posts/features/undo/",
            "url" : "https://blog.rockdata.net/posts/features/undo/","authors" : [
                {
                    "name" : "John Doe"
                }
            ],
            "content_html" : "\u003cp\u003eRedrock Postgres maintains records of the actions of transactions, collectively known as undo data. Redrock Postgres uses undo to do the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRoll back an active transaction\u003c/li\u003e\n\u003cli\u003eRecover a terminated transaction\u003c/li\u003e\n\u003cli\u003eProvide read consistency\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRedrock Postgres stores undo data inside the database rather than in external logs. Undo data is stored in blocks that are updated just like data blocks, with changes to these blocks generating redo. In this way, Redrock Postgres can efficiently access undo data without needing to read external logs.\u003c/p\u003e\n\u003cp\u003eUndo data is stored in an independent tablespace. Redrock Postgres provides a fully automated mechanism, known as automatic undo management mode, for managing undos and space.\u003c/p\u003e\n\u003cdiv class=\"gblog-post__anchorwrap flex align-center\"\u003e\n    \u003ch4 id=\"undos-and-transactions\"\u003e\n        Undos and Transactions\n    \u003c/h4\u003e\n    \u003ca data-clipboard-text=\"https://blog.rockdata.net/posts/features/undo/#undos-and-transactions\" class=\"gblog-post__anchor gblog-post__anchor--right clip\" aria-label=\"Anchor Undos and Transactions\" href=\"#undos-and-transactions\"\u003e\n        \u003csvg class=\"gblog-icon gblog_link\"\u003e\u003cuse xlink:href=\"#gblog_link\"\u003e\u003c/use\u003e\u003c/svg\u003e\n    \u003c/a\u003e\n\u003c/div\u003e\n\u003cp\u003eWhen a transaction starts, the database binds (assigns) the transaction to an undo segment, and therefore to a transaction table.\u003c/p\u003e\n\u003cp\u003eMultiple active transactions can write concurrently to the same undo or to different undos. For example, transactions T1 and T2 can both write to undo U1, or T1 can write to U1 while T2 writes to undo U2.\u003c/p\u003e\n\u003cdiv class=\"gblog-post__anchorwrap flex align-center\"\u003e\n    \u003ch4 id=\"transaction-rollback\"\u003e\n        Transaction Rollback\n    \u003c/h4\u003e\n    \u003ca data-clipboard-text=\"https://blog.rockdata.net/posts/features/undo/#transaction-rollback\" class=\"gblog-post__anchor gblog-post__anchor--right clip\" aria-label=\"Anchor Transaction Rollback\" href=\"#transaction-rollback\"\u003e\n        \u003csvg class=\"gblog-icon gblog_link\"\u003e\u003cuse xlink:href=\"#gblog_link\"\u003e\u003c/use\u003e\u003c/svg\u003e\n    \u003c/a\u003e\n\u003c/div\u003e\n\u003cp\u003eWhen a \u003ccode\u003eROLLBACK\u003c/code\u003e statement is issued, the database uses undo records to roll back changes made to the database by the uncommitted transaction. During recovery, the database rolls back any uncommitted changes applied from the online redo log to the data files. Undo records provide read consistency by maintaining the before image of the data for users accessing data at the same time that another user is changing it.\u003c/p\u003e\n"
        },
        {
            "title" : "PL/scheme, Procedural Language Handler",
            "date_published" : "2021-05-23T20:00:00+01:00",
            "date_modified" : "2022-05-23T20:20:52+08:00",
            "id" : "https://blog.rockdata.net/posts/advanced/plscheme/",
            "url" : "https://blog.rockdata.net/posts/advanced/plscheme/","authors" : [
                {
                    "name" : "John Doe"
                }
            ],
            "content_html" : "\u003cp\u003ePL/scheme is a PostgreSQL procedural language handler for Scheme programming language. PL/scheme uses Chibi Scheme in the background as its Scheme interpreter. With lots of builtin SRFIs and complete R7RS compliancy of Chibi Scheme, PL/scheme can power up PostgreSQL procedures in a Lisp style.\u003c/p\u003e\n\u003cdiv class=\"gblog-post__anchorwrap flex align-center\"\u003e\n    \u003ch2 id=\"features\"\u003e\n        Features\n    \u003c/h2\u003e\n    \u003ca data-clipboard-text=\"https://blog.rockdata.net/posts/advanced/plscheme/#features\" class=\"gblog-post__anchor gblog-post__anchor--right clip\" aria-label=\"Anchor Features\" href=\"#features\"\u003e\n        \u003csvg class=\"gblog-icon gblog_link\"\u003e\u003cuse xlink:href=\"#gblog_link\"\u003e\u003c/use\u003e\u003c/svg\u003e\n    \u003c/a\u003e\n\u003c/div\u003e\n\u003cp\u003eYou can find some of the supported features by PL/scheme in the below list.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExtensible native type support even for not created yet SQL data types. Domain, complex (ie. table\u0026rsquo;s row) and pseudo (record) types are supported as well.\u003c/li\u003e\n\u003cli\u003eIN, INOUT and OUT argument mode functionality,\u003c/li\u003e\n\u003cli\u003eCaching for non-volatile (and non-SRF) procedures per [top] transaction,\u003c/li\u003e\n\u003cli\u003eand any available feature supported by Chibi Scheme (fully R7RS compliancy, module system extension, full access to POSIX system calls, networking support, multiple threads, powerful string processing, lots of builtin SRFIs and may others) are naturally shipped with PL/scheme too.\u003c/li\u003e\n\u003c/ul\u003e\n"
        }
    ]
}
