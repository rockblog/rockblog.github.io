<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://gohugo.io/" version="0.99.1">Hugo</generator>
    <title>Features on Rockblog</title>
        <subtitle>Thought and work on the redrock postgres database</subtitle>
            <link href="http://blog.rockdata.net/tags/features/" rel="alternate" type="text/html" title="HTML" />
            <link href="http://blog.rockdata.net/tags/features/feed.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="http://blog.rockdata.net/tags/features/feed.json" rel="alternate" type="application/json" title="Json" />
    <updated>2022-05-28T18:42:16+08:00</updated>
        <author>
            <name>John Doe</name>
                <email>john@example.com</email>
        </author>
    <id>http://blog.rockdata.net/tags/features/</id>
        <entry>
            <title>Undo</title>
            <link href="http://blog.rockdata.net/posts/features/undo/" rel="alternate" type="text/html"  hreflang="en" />
            <id>http://blog.rockdata.net/posts/features/undo/</id>
                    <author>
                        <name>John Doe</name>
                    </author>
            <published>2020-06-13T00:06:00+02:00</published>
            <updated>2022-05-23T20:13:05+08:00</updated>
            <content type="html">
                &lt;p&gt;Redrock Postgres maintains records of the actions of transactions, collectively known as undo data. Redrock Postgres uses undo to do the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Roll back an active transaction&lt;/li&gt;
&lt;li&gt;Recover a terminated transaction&lt;/li&gt;
&lt;li&gt;Provide read consistency&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redrock Postgres stores undo data inside the database rather than in external logs. Undo data is stored in blocks that are updated just like data blocks, with changes to these blocks generating redo. In this way, Redrock Postgres can efficiently access undo data without needing to read external logs.&lt;/p&gt;
&lt;p&gt;Undo data is stored in an independent tablespace. Redrock Postgres provides a fully automated mechanism, known as automatic undo management mode, for managing undos and space.&lt;/p&gt;
&lt;div class=&#34;gblog-post__anchorwrap flex align-center&#34;&gt;
    &lt;h4 id=&#34;undos-and-transactions&#34;&gt;
        Undos and Transactions
    &lt;/h4&gt;
    &lt;a data-clipboard-text=&#34;http://blog.rockdata.net/posts/features/undo/#undos-and-transactions&#34; class=&#34;gblog-post__anchor gblog-post__anchor--right clip&#34; aria-label=&#34;Anchor Undos and Transactions&#34; href=&#34;#undos-and-transactions&#34;&gt;
        &lt;svg class=&#34;gblog-icon gblog_link&#34;&gt;&lt;use xlink:href=&#34;#gblog_link&#34;&gt;&lt;/use&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;When a transaction starts, the database binds (assigns) the transaction to an undo segment, and therefore to a transaction table.&lt;/p&gt;
&lt;p&gt;Multiple active transactions can write concurrently to the same undo or to different undos. For example, transactions T1 and T2 can both write to undo U1, or T1 can write to U1 while T2 writes to undo U2.&lt;/p&gt;
&lt;div class=&#34;gblog-post__anchorwrap flex align-center&#34;&gt;
    &lt;h4 id=&#34;transaction-rollback&#34;&gt;
        Transaction Rollback
    &lt;/h4&gt;
    &lt;a data-clipboard-text=&#34;http://blog.rockdata.net/posts/features/undo/#transaction-rollback&#34; class=&#34;gblog-post__anchor gblog-post__anchor--right clip&#34; aria-label=&#34;Anchor Transaction Rollback&#34; href=&#34;#transaction-rollback&#34;&gt;
        &lt;svg class=&#34;gblog-icon gblog_link&#34;&gt;&lt;use xlink:href=&#34;#gblog_link&#34;&gt;&lt;/use&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;When a &lt;code&gt;ROLLBACK&lt;/code&gt; statement is issued, the database uses undo records to roll back changes made to the database by the uncommitted transaction. During recovery, the database rolls back any uncommitted changes applied from the online redo log to the data files. Undo records provide read consistency by maintaining the before image of the data for users accessing data at the same time that another user is changing it.&lt;/p&gt;

            </content>  
                                <category scheme="http://blog.rockdata.net/authors/john-doe" term="john-doe" label="john-doe" />  
                                <category scheme="http://blog.rockdata.net/tags/documentation" term="documentation" label="Documentation" /> 
                                <category scheme="http://blog.rockdata.net/tags/features" term="features" label="Features" />
        </entry>
        <entry>
            <title>PL/scheme, Procedural Language Handler</title>
            <link href="http://blog.rockdata.net/posts/advanced/plscheme/" rel="alternate" type="text/html"  hreflang="en" />
            <id>http://blog.rockdata.net/posts/advanced/plscheme/</id>
                    <author>
                        <name>John Doe</name>
                    </author>
            <published>2021-05-23T20:00:00+01:00</published>
            <updated>2022-05-23T20:20:52+08:00</updated>
            <content type="html">
                &lt;p&gt;PL/scheme is a PostgreSQL procedural language handler for Scheme programming language. PL/scheme uses Chibi Scheme in the background as its Scheme interpreter. With lots of builtin SRFIs and complete R7RS compliancy of Chibi Scheme, PL/scheme can power up PostgreSQL procedures in a Lisp style.&lt;/p&gt;
&lt;div class=&#34;gblog-post__anchorwrap flex align-center&#34;&gt;
    &lt;h2 id=&#34;features&#34;&gt;
        Features
    &lt;/h2&gt;
    &lt;a data-clipboard-text=&#34;http://blog.rockdata.net/posts/advanced/plscheme/#features&#34; class=&#34;gblog-post__anchor gblog-post__anchor--right clip&#34; aria-label=&#34;Anchor Features&#34; href=&#34;#features&#34;&gt;
        &lt;svg class=&#34;gblog-icon gblog_link&#34;&gt;&lt;use xlink:href=&#34;#gblog_link&#34;&gt;&lt;/use&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;You can find some of the supported features by PL/scheme in the below list.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extensible native type support even for not created yet SQL data types. Domain, complex (ie. table&amp;rsquo;s row) and pseudo (record) types are supported as well.&lt;/li&gt;
&lt;li&gt;IN, INOUT and OUT argument mode functionality,&lt;/li&gt;
&lt;li&gt;Caching for non-volatile (and non-SRF) procedures per [top] transaction,&lt;/li&gt;
&lt;li&gt;and any available feature supported by Chibi Scheme (fully R7RS compliancy, module system extension, full access to POSIX system calls, networking support, multiple threads, powerful string processing, lots of builtin SRFIs and may others) are naturally shipped with PL/scheme too.&lt;/li&gt;
&lt;/ul&gt;

            </content>  
                                <category scheme="http://blog.rockdata.net/authors/john-doe" term="john-doe" label="john-doe" />  
                                <category scheme="http://blog.rockdata.net/tags/documentation" term="documentation" label="Documentation" /> 
                                <category scheme="http://blog.rockdata.net/tags/features" term="features" label="Features" />
        </entry>
</feed>
